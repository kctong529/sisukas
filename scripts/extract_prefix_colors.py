import json
from typing import Dict, List, Tuple


def extract_codes(courses: List[dict]) -> List[str]:
    return [
        c["code"]
        for c in courses
        if "code" in c and isinstance(c["code"], str) and c["code"]
    ]


def count_prefixes(codes: List[str]) -> Dict[str, int]:
    counts: Dict[str, int] = {}
    for code in codes:
        if "-" not in code:
            continue
        prefix = code.split("-", 1)[0]
        counts[prefix] = counts.get(prefix, 0) + 1
    return counts


def mix_with_white(rgb: Tuple[int, int, int], t: float) -> Tuple[int, int, int]:
    # t=0 -> original, t=1 -> white
    r, g, b = rgb
    return (
        round(r * (1 - t) + 255 * t),
        round(g * (1 - t) + 255 * t),
        round(b * (1 - t) + 255 * t),
    )


def assign_prefix_colors(prefix_counts: Dict[str, int]) -> Dict[str, Tuple[int, int, int]]:
    # Your base palette
    BASE: List[Tuple[int, int, int]] = [
        (234, 88, 12),   # c0 Burnt Orange
        (21, 128, 61),   # c1 Forest Green
        (124, 58, 237),  # c2 Deep Violet
        (2, 132, 199),   # c3 Sky Blue
        (245, 158, 11),  # c4 Amber
        (219, 39, 119),  # c5 Deep Pink
    ]
    LIGHT = [mix_with_white(c, 0.45) for c in BASE]  # 6 more distinct-ish colors
    OTHER = (148, 163, 184)  # slate-ish for long tail

    ranked = sorted(prefix_counts.items(), key=lambda x: x[1], reverse=True)

    out: Dict[str, Tuple[int, int, int]] = {}

    # Tier A: 12 most common => distinct colors (6 base + 6 light)
    tier_a = [p for p, n in ranked if n >= 90]
    distinct12 = BASE + LIGHT
    for i, prefix in enumerate(tier_a[:12]):
        out[prefix] = distinct12[i]

    # Tier B: 50â€“89 => cycle base colors (repeats ok)
    tier_b = [p for p, n in ranked if 50 <= n < 90]
    for i, prefix in enumerate(tier_b):
        out[prefix] = BASE[i % len(BASE)]

    # Tier C: < 50 => shared color
    for prefix, n in ranked:
        if n < 50:
            out[prefix] = OTHER

    # default fallback key
    out["__OTHER__"] = OTHER
    return out


def rgb_to_str(rgb: Tuple[int, int, int]) -> str:
    r, g, b = rgb
    return f"{r}, {g}, {b}"


def write_ts_module(
    prefix_counts: Dict[str, int],
    prefix_colors: Dict[str, Tuple[int, int, int]],
    out_path: str = "coursePrefixColors.ts",
) -> None:
    ranked = sorted(prefix_counts.items(), key=lambda x: x[1], reverse=True)

    lines: List[str] = []
    lines.append("// AUTO-GENERATED by extract_prefix_colors.py. Do not edit by hand.")
    lines.append("")
    lines.append("export const COURSE_PREFIX_RGB: Record<string, string> = {")
    for prefix, count in ranked:
        rgb = prefix_colors.get(prefix, prefix_colors["__OTHER__"])
        lines.append(f'  "{prefix}": "{rgb_to_str(rgb)}", // {count}')
    # ensure fallback exists
    lines.append(f'  "__OTHER__": "{rgb_to_str(prefix_colors["__OTHER__"])}",')
    lines.append("};")
    lines.append("")

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))


def main() -> None:
    with open("courses.json", "r", encoding="utf-8") as f:
        courses = json.load(f)

    codes = extract_codes(courses)
    prefix_counts = count_prefixes(codes)
    prefix_colors = assign_prefix_colors(prefix_counts)

    write_ts_module(prefix_counts, prefix_colors, out_path="coursePrefixColors.ts")

    # Optional: print a quick preview (top 20)
    ranked = sorted(prefix_counts.items(), key=lambda x: x[1], reverse=True)[:20]
    for p, n in ranked:
        print(f"{p}: {n} -> {rgb_to_str(prefix_colors.get(p, prefix_colors['__OTHER__']))}")


if __name__ == "__main__":
    main()
